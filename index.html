<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>별자리 수호대</title>
    <style>
        body {
            background-color: #00001a;
            color: #eee;
            font-family: 'Segoe UI', 'Malgun Gothic', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 20px;
            overflow: hidden;
            height: 100vh;
        }
        h1 {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            margin: 0;
        }
        canvas {
            background-color: #000;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            cursor: pointer;
            touch-action: none; /* 모바일에서 터치 시 화면 스크롤 방지 */
            max-width: 100%;
            max-height: 80%;
        }
        .ui-container {
            display: flex;
            justify-content: space-between;
            width: 800px;
            max-width: 90%;
            margin-top: 15px;
            font-size: 1.2em;
            font-weight: bold;
        }
        .ui-item {
            flex: 1;
            text-align: center;
        }
    </style>
</head>
<body>

    <h1>✨ 별자리 수호대 ✨</h1>
    <div class="ui-container">
        <div class="ui-item">점수: <span id="score">0</span></div>
        <div class="ui-item">스테이지: <span id="stage">1</span></div>
        <div class="ui-item">최고 점수: <span id="highScore">0</span></div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        // 1. 캔버스 및 UI 요소 설정
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('highScore');
        const stageEl = document.getElementById('stage');

        // 캔버스 크기 설정 (화면에 맞게 조정)
        const canvasSize = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.7, 800);
        canvas.width = canvasSize;
        canvas.height = canvasSize * 0.75; // 4:3 비율

        // 2. 게임 상태 및 변수
        let gameState = 'waiting'; // 'waiting', 'playing', 'stageClear', 'gameOver'
        let score = 0;
        let stage = 1;
        let highScore = localStorage.getItem('constellationRunHighScore') || 0;
        highScoreEl.innerText = highScore;

        const keys = {};
        let stars = [];
        let comets = [];

        // 3. 사운드 이펙트 (Web Audio API)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); // 볼륨

            if (type === 'star') {
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // '라' 음
                gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.3);
            } else if (type === 'explosion') {
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(220, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(55, audioCtx.currentTime + 0.5);
                gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.5);
            } else if (type === 'clear') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(523, audioCtx.currentTime); // '도'
                oscillator.frequency.linearRampToValueAtTime(1046, audioCtx.currentTime + 0.5); // 높은 '도'
                gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.6);
            }

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.5);
        }

        // 4. 플레이어(UFO) 객체
        const player = {
            width: canvas.width * 0.04,
            height: canvas.width * 0.04,
            speed: canvas.width * 0.007,
            dx: 0,
            dy: 0,
            trail: [],
            reset: function() {
                this.x = canvas.width / 2 - this.width / 2;
                this.y = canvas.height / 2 - this.height / 2;
                this.trail = [];
                this.dx = 0;
                this.dy = 0;
            }
        };

        // 5. 별자리 데이터 (캔버스 크기에 상대적인 좌표)
        const constellationData = {
            1: {
                name: '카시오페아',
                stars: [
                    { x: 0.15, y: 0.3 }, { x: 0.3, y: 0.5 }, { x: 0.5, y: 0.3 },
                    { x: 0.7, y: 0.5 }, { x: 0.85, y: 0.3 }
                ]
            },
            2: {
                name: '북두칠성',
                stars: [
                    { x: 0.2, y: 0.7 }, { x: 0.3, y: 0.5 }, { x: 0.4, y: 0.3 },
                    { x: 0.55, y: 0.2 }, { x: 0.65, y: 0.5 }, { x: 0.8, y: 0.55 }, { x: 0.9, y: 0.6 }
                ]
            },
            3: {
                name: '백조자리',
                stars: [
                    { x: 0.5, y: 0.15 }, { x: 0.5, y: 0.6 }, { x: 0.5, y: 0.8 }, // 세로
                    { x: 0.2, y: 0.45 }, { x: 0.35, y: 0.45 }, { x: 0.65, y: 0.45 }, { x: 0.8, y: 0.45 } // 가로
                ]
            }
        };

        // 6. 그리기 함수들
        function drawPlayer() {
            // 궤적
            player.trail.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 255, 255, ${p.opacity})`;
                ctx.fill();
            });

            // UFO 본체 (접시)
            ctx.fillStyle = '#aaa';
            ctx.beginPath();
            ctx.ellipse(player.x + player.width / 2, player.y + player.height * 0.7, player.width / 2, player.height / 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // UFO 돔
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(player.x + player.width / 2, player.y + player.height * 0.5, player.width / 3, Math.PI, 0);
            ctx.fill();
        }

        function drawStars() {
            stars.forEach(star => {
                ctx.save();
                ctx.translate(star.x, star.y);
                ctx.fillStyle = 'yellow';
                ctx.strokeStyle = 'gold';
                ctx.lineWidth = 2;
                ctx.shadowColor = 'yellow';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    ctx.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * 12, -Math.sin((18 + i * 72) / 180 * Math.PI) * 12);
                    ctx.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * 5, -Math.sin((54 + i * 72) / 180 * Math.PI) * 5);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            });
            ctx.shadowBlur = 0;
        }

        function drawComets() {
            comets.forEach(comet => {
                const gradient = ctx.createLinearGradient(comet.x, comet.y, comet.x, comet.y + comet.height);
                gradient.addColorStop(0, 'white');
                gradient.addColorStop(0.3, 'orangered');
                gradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(comet.x, comet.y, comet.width / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillRect(comet.x - comet.width/2, comet.y, comet.width, comet.height);
            });
        }
        
        function drawUI(text, yOffset = 0) {
            ctx.textAlign = 'center';
            ctx.fillStyle = 'white';
            ctx.font = `${canvas.width * 0.05}px sans-serif`;
            ctx.fillText(text, canvas.width / 2, canvas.height / 2 + yOffset);
        }

        // 7. 게임 로직 함수들
        function loadStage(level) {
            const data = constellationData[level];
            if (!data) { // 모든 스테이지 클리어
                gameState = 'gameOver';
                return false;
            }
            stageEl.innerText = level;
            // 캔버스 크기에 맞춰 별 좌표 변환
            stars = data.stars.map(s => ({
                x: s.x * canvas.width,
                y: s.y * canvas.height,
                radius: 12
            }));
            return true;
        }

        function resetGame() {
            stage = 1;
            score = 0;
            scoreEl.innerText = score;
            comets = [];
            player.reset();
            if (loadStage(1)) {
                gameState = 'playing';
            }
        }
        
        function updatePlayer() {
            // 키보드 이동
            player.x += player.dx;
            player.y += player.dy;

            // 화면 경계 처리
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            if (player.y < 0) player.y = 0;
            if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
            
            // 궤적 업데이트
            player.trail.push({ x: player.x + player.width / 2, y: player.y + player.height * 0.7, opacity: 1 });
            player.trail.forEach(p => p.opacity -= 0.02);
            player.trail = player.trail.filter(p => p.opacity > 0);
        }

        function updateComets() {
            const spawnChance = 0.01 + stage * 0.005;
            if (Math.random() < spawnChance && comets.length < 5 + stage * 2) {
                comets.push({
                    x: Math.random() * canvas.width,
                    y: 0,
                    width: canvas.width * 0.015,
                    height: canvas.height * 0.05,
                    speed: 1.5 + stage * 0.5
                });
            }

            comets.forEach((comet, index) => {
                comet.y += comet.speed;
                if (comet.y > canvas.height) {
                    comets.splice(index, 1);
                }
            });
        }

        function checkCollisions() {
            // 별 충돌
            stars.forEach((star, index) => {
                const dist = Math.hypot(player.x + player.width / 2 - star.x, player.y + player.height / 2 - star.y);
                if (dist < player.width / 2 + star.radius) {
                    playSound('star');
                    stars.splice(index, 1);
                    score++;
                    scoreEl.innerText = score;
                }
            });

            // 혜성 충돌
            comets.forEach(comet => {
                if (player.x < comet.x + comet.width &&
                    player.x + player.width > comet.x - comet.width &&
                    player.y < comet.y + comet.height &&
                    player.y + player.height > comet.y) 
                {
                    playSound('explosion');
                    gameState = 'gameOver';
                }
            });
        }

        function update() {
            if (gameState !== 'playing') return;
            
            updatePlayer();
            updateComets();
            checkCollisions();

            if (stars.length === 0) {
                playSound('clear');
                gameState = 'stageClear';
                score += 5; // 스테이지 클리어 보너스
                setTimeout(() => {
                    stage++;
                    player.reset();
                    if(loadStage(stage)) {
                        gameState = 'playing';
                    }
                }, 2000);
            }
        }
        
        // 8. 메인 게임 루프
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'waiting') {
                drawStars(); // 배경으로 현재 스테이지 별 보여주기
                drawUI('별자리 수호대');
                drawUI('클릭하여 시작', canvas.width * 0.08);
            } else if (gameState === 'playing') {
                update();
                drawStars();
                drawComets();
                drawPlayer();
            } else if (gameState === 'stageClear') {
                drawUI(`스테이지 ${stage} 클리어!`);
                drawPlayer(); // 클리어 시 UFO 보여주기
            } else if (gameState === 'gameOver') {
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('constellationRunHighScore', highScore);
                    highScoreEl.innerText = highScore;
                }
                drawUI('게임 오버', -canvas.width * 0.05);
                drawUI(`최종 점수: ${score}`, canvas.width * 0.05);
                drawUI('다시 시작하려면 클릭', canvas.width * 0.12);
            }
            
            requestAnimationFrame(gameLoop);
        }

        // 9. 이벤트 리스너
        // 키보드
        document.addEventListener('keydown', e => {
            keys[e.key] = true;
            updatePlayerMovement();
        });
        document.addEventListener('keyup', e => {
            keys[e.key] = false;
            updatePlayerMovement();
        });

        function updatePlayerMovement() {
            player.dx = 0;
            player.dy = 0;
            if (keys['ArrowRight'] || keys['d']) player.dx = player.speed;
            if (keys['ArrowLeft'] || keys['a']) player.dx = -player.speed;
            if (keys['ArrowDown'] || keys['s']) player.dy = player.speed;
            if (keys['ArrowUp'] || keys['w']) player.dy = -player.speed;
        }

        // 마우스 및 터치
        function handleInteraction(e) {
            e.preventDefault();
            if (gameState === 'waiting' || gameState === 'gameOver') {
                if(audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                resetGame();
            }
        }
        
        function handleMove(e) {
            if (gameState !== 'playing') return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - rect.left;
            const y = (e.clientY || e.touches[0].clientY) - rect.top;

            player.x = x - player.width / 2;
            player.y = y - player.height / 2;
        }
        
        canvas.addEventListener('click', handleInteraction);
        canvas.addEventListener('touchstart', handleInteraction, { passive: false });

        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        
        // 10. 게임 시작
        player.reset();
        loadStage(1);
        gameLoop();

    </script>
</body>
</html>
